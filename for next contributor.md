# FOR NEXT WECODE CONTRIBUTOR
이 글은 4기 박경연에 의하여 작성되었습니다. 위코드에서 aws람다를 통해 개발을 진행하고 계실 여러분을 위하여 이 글을 작성합니다. 이 글을 통해 제가 작성한 람다 함수의 코드를 어느정도 이해하고 잘 개선시켜주시리라 믿습니다. 더불어 이 글은 매우 초심자적인 입장에서 적었음을 양해 부탁드립니다.

(#우선 람다가 처음이시면, Youtube **동빈 나**의 람다 강의를 듣고 시작하시기를 추천합니다.)

## 1. 람다 시스템?인프라? 관련
제가 이해한 람다로 API를 만드는 과정은 이러합니다.
1. 람다함수 생성
2. 로직 구현
3. API Gateway에서 API생성 후 리소스와 메소드, 연결할 람다함수 결정
4. CORS 활성화 처리
5. API배포
6. httpie로 테스트
7. 프론트와 연동

이제 주의할 점을 하나씩 설명하겠습니다.

### 람다함수 핸들러
우선 말씀 드릴 부분은 **람다 함수의 핸들러는 한개만 지정할 수 있다**는 것입니다.
람다 함수 코드 입력창 상단에 보시면 "핸들러" 라는게 보입니다.
만약 당신이 실행할 메인 로직의 함수명을 바꾸면, 그에 따라 저 핸들러명도 바뀌어야 합니다. 그리고 핸들러를 한개만 지정할 수 있다는 것은, 당신이 API호출을 통해 실행할 수 있는 함수도 한개라는 의미입니다.
한개의 엔드포인트 주소에 메소드에 따라 다른 함수를 실행하고싶다면, 라우팅을 통해 함수가 함수를 호출해와서 실행시키는 방법이 있으나 저는 구현하지 않았습니다.

### 람다 함수의 변수
http **request = event**정도로 생각해주시면 될 것 같습니다.
django에서는 리퀘스트를 인자로 받았지만, 람다에서는 이벤트를 인자로 받습니다.
event의 생김새를 알아내는 가장 좋은 방법은 프린트를 찍어보는 방법입니다.
람다 함수에 ```print(event)``` 만 입력하고, 트리거에서 아무 API게이트웨이나 지정해준다음, 그 주소를 웹 브라우저로 실행시키면 호출이 일어나고 로그에 이벤트가 찍혀서 그 형태를 알 수 있습니다.
로그는 람다함수 인터넷 브라우저 창에서 모니터링을 클릭한 후, 우측의 CloudWatch에서 로그 보기에 가면, API별로 기록된 로그를 확인할 수 있습니다. 여기에 아까 찍은 event가 찍혀있을 테니 한번 찍어보고, 바디와 헤더를 지지고 볶고 하시면 되겠습니다.

### API Gateway활용
저희가 기존에 사용하던 것처럼 기능에 따라 엔드포인트 주소를 구분해주기 위해서는, 브라우저의 람다함수 콘솔(브라우저창)이 아닌 API Gateway의 API생성을 통해 원하는 이름과 주소의 API를 생성한 후, 람다 콘솔에서 트리거로 지정해 주면됩니다. (생성 자체는 위에서 공유드린 동영상 강의에서 배울 수 있습니다.)
각 함수의 기능에 따라 엔드포인트 주소를 지정하고 싶을 경우, 위에서 생성한 API의 리소스에서 **리소스 -> 작업 -> 리소스 생성**을 통해 주소를 지정해줄 수 있습니다. 이후 이 리소스가 선택된 상태에서 **작업 -> 메소드 생성** 을 통해 원하는 메소드를 추가해 줄 수 있으며, 이 과정에서, 람다함수 지정을 통해 실행시킬 함수를 정합니다.

###  CORS 관련 주의 사항
django에서는 패키지를 통해 CORS 관련 에러들을 만나지 않고 지나올 수 있었지만, 람다에서는 그렇지 않습니다. 물론 람다에도 어느정도 CORS에 관련된 사항들을 설정해주기는 하지만, 왜인지 저는 막판에 프론트와 붙이는 과정에서 에러를 만났습니다.(동영상 강의에서 보았던 CORS활성화 세팅은 해주었습니다. 뭔가 잘못 했을 수도 있겠지만....)
**삽질 기록 & 개선점** : 제가 썼던 함수에서 리턴하는 모든 리턴값에는 다음과 같은 헤더가 포함됩니다.(Authorizer 제외)
```python
    return {
        'statusCode': 200,
        'headers' : {
            'Access-Control-Allow-Origin' : '*'
        },
        'body'      : json.dumps({'result' : result})
    }
```
프론트에서 fetch 하는 과정에서 Access-Control-Allow-Origin이라는 헤더값이 없다는 메시지에 따라서 이를 추가해 주었고 이후 정상 작동하는 모습을 확인 할 수 있었습니다. CORS를 활성화하면서 저부분에 대해서 자동으로 헤더가 붙도록 설정된 줄 알았으나, 붙지않고있어 우선 추가해주는 방법으로 해결하였는데, 저의 설정이 잘못되었거나, 이보다 좋은 해결책이 있으리라고 생각합니다.

### Authorizer 관련 주의사항

django에서 처럼 utils.py를 작성해놓고, 인증 데코레이터를 사용하는 방법을 람다에서 구현하려면,
1. 해당 파이썬 파일을 레이어에 올려놓거나
2. Custom Authorizer를 사용할 수 있습니다.

필자의 경우는 2번을 사용하였고 해당 부분의 세팅에서 삽질한 내용을 공유합니다.

1. 토큰의경우 헤더에 실어서 보낸다고하더라도 람다 Authorizer에서는 ```event['authorizationToken']```으로 들어옵니다. 콘솔의 권한부여자에서 Authorizer를 만들때 원래 토큰이 어디있는지 헤더의 이름을 입력할 수 있는데 이부분에서 자동으로 이벤트의 키와 밸류로 보내주도록 변환됩니다.
2. 다음은 리턴하는 값의 모양입니다.
```
'policyDocument' : {
                "Version"    : "2012-10-17",
                "Statement"  : [
                    {
                        "Action"  : "execute-api:Invoke",
                        "Effect"  : "Deny",
                        "Resource": [
                            "arn:aws:execute-api:ap-northeast-2:194148625732:aq9yrbcbg5/*/GET/users/batch-view",
                            "arn:aws:execute-api:ap-northeast-2:194148625732:aq9yrbcbg5/*/POST/users/registration"
                        ]
                    }
                ]
            }
```
Version : 공식 도큐먼트에서 해당 날짜가 가장 최신이라고 봐서 해당 날짜를 사용했습니다.
Action : 해당 함수가 실행된 후 이어질 할 행동
Effect : 해당 리턴값에서 실행될 행동의 허가 여부 (Accept / Deny)
Resource : 해당 함수가 실행되면 이어서 실행되어야하는 행동의 리소스arn값
(해당 Authorizer를 여러 함수에서 사용하게될 경우 이부분에 arn을 추가해주면 됩니다.)            


## 2. 패키지 (레이어) 관련

django로 프로젝트를 진행할때는 miniconda를 사용하여 내가 필요한 패키지를 모두 설치하고 끌어다 썼습니다. 그러나 람다는 다릅니다. 람다에서도 패키지는 사용할 수 있지만, 용량 문제로 인해 최소한으로 가지고 가는것이 좋습니다.
필자는 mysql-connector-python, PyJWT, requests 요 세가지 패키지와 registration함수에서 메일 전송에 사용할 letter.py와 DB 접근 및 각종 키 정보들을 담은 my_settings.py를 한개의 zip 파일로 묶어서 업로드한 후 사용하였습니다. (약 22MB)
그러나 이부분도 10MB가 넣을 경우, S3에 패키지모음을 올린 후 끌어다 쓰는 방법을 권하고 있기때문에, 추후 개선이 필요해 보입니다.
**개선점** : my_settings에 포함된 DB정보, API키, 비밀번호 등의 노출되지 않아야 하는 정보는 레이어에 올리는 것 보다는 aws에서 제공하는 KMS와 같은 서비스를 이용해 보안을 잡는 것이 권장되는 방법인 걸로 알고 있습니다. 이 부분에 대한 개선은 추후에 진행 시 고려되면 좋을 것 같습니다.
`
## 3. 로직 관련
각 로직을 코딩한 의도와 개선점에 대해서 기술하겠습니다.

### batch_view
**로직 설명** : 단순히 기수를 headers 에서 int 값으로 받으면, 받은 int값에 해당하는 기수의 학생 목록을 불러오고, 해당 키 자체가 존재하지 않을 경우, 모든 회원을 불러오는 함수입니다.

**개선점** : batch값자체가 int값이고 딱히 정보성을 띄고있지 않아서, 이 부분을 쿼리스트링으로 받아올 수 있도록 처리하고, 기본값을 null로 둔 후, null일 경우에 모든 회원을 불러오는 로직으로 개선하는것이 좀더 좋아보입니다. 
```python
event["queryStringParameters"]["batch"]
```
요런 형식으로 쿼리스트링을 불러온 다는 것은 알았는데, 해당 쿼리스트링이 들어오지 않았을 때의 처리를 시간상 해결하지 못해서 현재는 headers에서 "batch" 키를 불러오는 방식입니다.
단순히 

### registration
**로직 설명** : 크게 사용자 등록과 메일 전송 부분으로 나뉩니다. 기존에는 로직이 두개로 나뉘어져 있었으나, 예리님이 등록과 함께 메일 전송까지 하고 싶다는 피드백을 주셔서 수정했습니다.
1. body로 데이터 수신
2. DB 접속하여 들어온 유저들을 비활성화된 상태로 저장
3. body로 수신된 메일주소들을 통해 DB에 저장된 유저정보들을 다시 호출
4. smtp를 통해 각 유저들에게 gmail로 메일 발신(파이썬 내장라이브러리입니다)
5. 메일의 내용인 letter.py는 레이어화 하여 올려놓았고 깃헙에도 남겨놓을테니 사용하시면 됩니다.(제입맛대로 변수명은 조금 변경된 부분이 있습니다.)
6. 각 메일에는 해당 유저가 관리자에 의해 등록되고 메일이 보내진 유저인지를 확인하기 위해 메일 내부 링크 접속 시 jwt를 쿼리스트링으로 넘겨주게 되어 있습니다. 이를 프론트에서 받아, 깃헙 로그인 로직에서 확인하기 위함입니다.

**개선점**

1. 이메일 정규식같은 부분을 추가해서 최대한 메일주소를 정확하게 쓸 수 있도록 유도 하는 것이 좋을듯 합니다.
2. 계정 중복 등록 여부 확인에 대한 검사가 하나도 없습니다. 현재 같은 이메일로 2개 이상의 row가 만들어지면 같은 이메일에 초대메일 2개가 갈 가능성이 있어서, 이 부분에 대한 핸들링이 필요합니다.
3. 개별적으로 이메일을 못받았거나 오류로 등록이 안된 경우를 대비하여, 유저 정보 수정, 개별 메일 발송이 가능한 API가 수정되면 좋을 것 같습니다.

### github-login

**로직 설명** : 프론트에서 로그인정보를 받아와 깃헙에 토큰을 요청하고, 해당 토큰으로 깃헙 네임을 받아와서 회원가입 /로그인을 진행합니다.
1. 우선 프론트에서 코드와 스테이트를 받습니다.
2. 코드와 스테이트가 비어있으면 에러를 반환합니다.
3. 깃헙에 코드/스테이트를 보내 깃헙 oauth토큰을 받습니다
4. 해당 토큰을 가지고 접속한 유저의 github_name을 알아냅니다.
5. github_name이 db에 없으나 jwt가 있으면 신규유저로 인식하고 해당 계정을 활성화, github_name을 등록합니다.
6. github_name이 db에 없고 jwt또한 없으면 잘못된 접근으로 판단하여 에러를 리턴합니다.
7. 이외의 경우는 기존유저로 판단하여 로그인 토큰을 발행합니다

**개선점**
1. 뭔가 케이스 핸들링이 좀더 세세하고 명확하게 나누어져야할 것 같습니다. 
ex) A유저의 메일 링크를 타고 들어왔으나 브라우저에 B유저의 깃헙으로 로그인되어있는 경우, B유저가 저희 DB에 등록된 유저이면 B유저로 로그인이 됩니다. 
2. 메일에서 발급해주는 jwt와 로그인 시에 발급해주는 jwt의 내용이 전부 id값밖에없어서 보안상 이를 다르게 관리하는게 좀더 좋다고 보여집니다.
 


